-- =====================================================
-- AI English Learning - Database Initialization Script
-- Created: 2025-06-24 12:10:00
-- =====================================================

-- =====================================================
-- 1. Create user_usage table for daily play tracking
-- =====================================================
DROP TABLE IF EXISTS public.user_usage;
CREATE TABLE public.user_usage (
  id uuid REFERENCES auth.users ON DELETE CASCADE NOT NULL PRIMARY KEY,
  daily_play_count integer NOT NULL DEFAULT 0,
  last_play_date date DEFAULT current_date,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Enable RLS
ALTER TABLE public.user_usage ENABLE ROW LEVEL SECURITY;

-- Create policies for user_usage (NextAuth compatible)
DROP POLICY IF EXISTS "Allow all operations for user_usage" ON public.user_usage;
CREATE POLICY "Allow all operations for user_usage"
  ON public.user_usage FOR ALL
  USING (true)
  WITH CHECK (true);

-- Create function to update updated_at
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS trigger AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger
DROP TRIGGER IF EXISTS on_user_usage_updated ON public.user_usage;
CREATE TRIGGER on_user_usage_updated
  BEFORE UPDATE ON public.user_usage
  FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();

-- =====================================================
-- 2. Enable RLS on users table and create policies
-- =====================================================
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if they exist
DROP POLICY IF EXISTS "Users can view their own data." ON public.users;
DROP POLICY IF EXISTS "Enable insert for authenticated users only" ON public.users;
DROP POLICY IF EXISTS "Users can update their own data." ON public.users;

-- Create policy to allow users to view their own data
CREATE POLICY "Users can view their own data." 
ON public.users FOR SELECT 
USING (auth.uid() = id);

-- Create policy to allow authenticated users to insert their own data
CREATE POLICY "Enable insert for authenticated users only" 
ON public.users FOR INSERT 
WITH CHECK (auth.role() = 'authenticated');

-- Create policy to allow users to update their own data
CREATE POLICY "Users can update their own data." 
ON public.users FOR UPDATE 
USING (auth.uid() = id);

-- =====================================================
-- 3. Add role column to users table for admin access
-- =====================================================
ALTER TABLE public.users ADD COLUMN IF NOT EXISTS role TEXT DEFAULT 'user';

-- Add a check constraint to ensure the role is one of the allowed values
ALTER TABLE public.users DROP CONSTRAINT IF EXISTS user_role_check;
ALTER TABLE public.users ADD CONSTRAINT user_role_check CHECK (role IN ('user', 'admin'));

-- =====================================================
-- 4. Create user_vocabulary table for vocabulary management
-- =====================================================
CREATE TABLE IF NOT EXISTS public.user_vocabulary (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id uuid REFERENCES auth.users NOT NULL,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  word text NOT NULL,
  meaning_en text,
  meaning_zh text,
  example text,
  CONSTRAINT user_vocabulary_user_id_word_key UNIQUE (user_id, word)
);

ALTER TABLE public.user_vocabulary ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if they exist
DROP POLICY IF EXISTS "Users can insert their own vocabulary." ON public.user_vocabulary;
DROP POLICY IF EXISTS "Users can view their own vocabulary." ON public.user_vocabulary;
DROP POLICY IF EXISTS "Users can update their own vocabulary." ON public.user_vocabulary;
DROP POLICY IF EXISTS "Users can delete their own vocabulary." ON public.user_vocabulary;

-- Create policies for user_vocabulary (NextAuth compatible)
CREATE POLICY "Users can insert their own vocabulary."
  ON public.user_vocabulary FOR INSERT
  WITH CHECK (true);

CREATE POLICY "Users can view their own vocabulary."
  ON public.user_vocabulary FOR SELECT
  USING (true);

CREATE POLICY "Users can update their own vocabulary."
  ON public.user_vocabulary FOR UPDATE
  USING (true);

CREATE POLICY "Users can delete their own vocabulary."
  ON public.user_vocabulary FOR DELETE
  USING (true);

-- =====================================================
-- 5. Create daily reset and increment functions
-- =====================================================
-- Function to check and reset daily play count if it's a new day
CREATE OR REPLACE FUNCTION public.check_and_reset_daily_play_count(user_id uuid)
RETURNS integer AS $$
DECLARE
  current_play_count integer;
  v_last_play_date date;
  today_date date := current_date;
BEGIN
  -- Get current usage data
  SELECT daily_play_count, last_play_date 
  INTO current_play_count, v_last_play_date
  FROM public.user_usage 
  WHERE id = user_id;
  
  -- If no record exists, create one
  IF current_play_count IS NULL THEN
    INSERT INTO public.user_usage (id, daily_play_count, last_play_date)
    VALUES (user_id, 0, today_date);
    RETURN 0;
  END IF;
  
  -- If it's a new day, reset the play count
  IF v_last_play_date < today_date THEN
    UPDATE public.user_usage 
    SET daily_play_count = 0, last_play_date = today_date
    WHERE id = user_id;
    RETURN 0;
  END IF;
  
  -- Return current play count
  RETURN current_play_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to increment play count
CREATE OR REPLACE FUNCTION public.increment_play_count(user_id uuid)
RETURNS integer AS $$
DECLARE
  new_count integer;
BEGIN
  -- First check and reset if needed
  PERFORM public.check_and_reset_daily_play_count(user_id);
  
  -- Then increment the count
  UPDATE public.user_usage 
  SET daily_play_count = daily_play_count + 1
  WHERE id = user_id;
  
  -- Return the new count
  SELECT daily_play_count INTO new_count
  FROM public.user_usage 
  WHERE id = user_id;
  
  RETURN new_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant execute permissions
GRANT EXECUTE ON FUNCTION public.check_and_reset_daily_play_count(uuid) TO authenticated;
GRANT EXECUTE ON FUNCTION public.increment_play_count(uuid) TO authenticated;

-- =====================================================
-- 6. Verify all policies are created
-- =====================================================
-- Verify user_usage policies
SELECT 
  schemaname,
  tablename,
  policyname,
  permissive,
  roles,
  cmd,
  qual,
  with_check
FROM pg_policies 
WHERE tablename = 'user_usage';

-- Verify users policies
SELECT 
  schemaname,
  tablename,
  policyname,
  permissive,
  roles,
  cmd,
  qual,
  with_check
FROM pg_policies 
WHERE tablename = 'users';

-- Verify user_vocabulary policies
SELECT 
  schemaname,
  tablename,
  policyname,
  permissive,
  roles,
  cmd,
  qual,
  with_check
FROM pg_policies 
WHERE tablename = 'user_vocabulary';

-- =====================================================
-- 7. Display table structure summary
-- =====================================================
SELECT 
  table_name,
  column_name,
  data_type,
  is_nullable,
  column_default
FROM information_schema.columns 
WHERE table_schema = 'public' 
  AND table_name IN ('users', 'user_usage', 'user_vocabulary')
ORDER BY table_name, ordinal_position;

-- =====================================================
-- Initialization Complete
-- ===================================================== 